---
layout: post
title: 'Keychain Forensics : Part I'
date: 2013-06-06 22:49:00.000000000 +09:00
type: post
published: true
status: publish
categories:
- OS Artifacts
tags: []
meta:
  blogger_blog: forensic.n0fate.com
  blogger_author: Kyeongsik Lee
  blogger_permalink: /2013/06/keychain-forensics-part-i.html
  _blogger_self: https://www.blogger.com/feeds/7620918615785302711/posts/default/5956870713473218215
  _oembed_d69e8097cc08a244d4a8483691e48f76: '{{unknown}}'
  avada_post_views_count: '1145'
  fusion_builder_content_backup: |-
    디지털 포렌식 분석을 진행 과정에서 사용자의 기밀 정보는 매우 유용한 정보 중 하나이다. 보통 사용자는 자신에게 불리할 수 있는 증거를 숨기기 위해 데이터를 암호화하여 보관하거나, 인증을 통해서만 접근 가능한 환경에 보관하기 때문에 수사관 입장에서는 이러한 정보를 수집하기 쉽지 않다. 물론 갖은 회유와 협박을 통해 인증 정보를 수집할 순 있겠으나, 사용자가 이를 거부하는 경우에는 전수조사를 제외하곤 대책이 없다. (다른 방법이 있을 수 있으나, 적어도 내가 아는 상황에서는 그렇다.)<br /><br />사용자는 자체적인 정보 암호화 알고리즘을 사용할 수도 있으나, 보통은 이미 안정성이 입증된 솔루션을 사용한다. 이러한 정보는 보통 다음과 같은 장소에 보관한다.<br /><ul><li>자체 암호화 솔루션 사용 : 암호화 프로그램을 통해 데이터를 암호화하거나, 파일 형태의 암호화 볼륨을 생성하여 데이터를 관리할 수 있게 한다. 대표적으로 TrueCrypt가 있다.</li><li>운영체제에서 지원하는 암호화 기능 사용 : 운영체제에서 제공하는 전체 디스크 암호화나 특정 파일 암호화 기술을 사용하여 데이터를 보관한다. 대표적으로 윈도우의 Bitlocker와 Mac OS X의 FileVault2, Keychain System이 있다.</li><li>클라우드 서비스 사용 : 외부 저장소 서비스를 이용하여 데이터를 저장하는 방법이다. Google Docs, Dropbox, Evernote 등이 있다.</li></ul>이런 다양한 정보 중에 오늘 글에서 다룰 내용은 키체인(Keychain) 분석이다. Mac OS X는 사용자 기밀 정보를 저장하기 위해 키체인(Keychain) 시스템을 운영하고 있다. 키체인 시스템은 사용자 정보를 3DES로 암호화하여 저장하고 있다. 키체인에는 Mac OS X에 저장되는 대부분의 기밀 정보를 저장한다. 대표적인 정보는 다음과 같다.<br /><ul><li>웹서비스 계정 정보 : Safari나 Chrome과 같은 웹 브라우저를 통해 저장되는 Dropbox, Evernote 등의 웹서비스 계정 정보</li><li>메신저 서비스 계정 정보 : Adium이나 iMessage에서 저장한 사용자 계정 정보</li><li>암호화된 볼륨 패스워드 : Mac OS X 사용자는 외부 저장 장치의 데이터를 암호화하여 보관하기 위해 해당 볼륨을 FileVault2로 암호화할 수 있다. 만약 암호화 볼륨을 마운트하는 과정에서 편의를 위해 사용자 패스워드를 저장하도록하면, 키체인에서 추출할 수 있다.</li><li>이메일, 연락처, 일정 계정 정보 : Mac OS X에서 기본적으로 제공하는 PIM(Personal Information Management) 시스템은 여러 클라우드 서비스와 연동이 가능하다. 연동한 계정의 ID와 패스워드가 키체인에 저장되어 있다.</li><li>기타 애플리케이션 암호화 정보 : 애플리케이션 개발자가 Mac OS X의 키체인 API를 사용하는 경우 암호화한 모든 데이터가 키체인 파일에 저장된다.</li><li>보안 노트 : 사용자가 정보를 은닉하기 위해 키체인 파일 내부에 RIch File Format의 문서를 생성할 수 있다. 대부분의 포렌식 수사관이 Mac OS X에 친숙하지 않아 분석에서 제외되는 경우가 많다보니, 이 곳에 정보를 은닉할 수 있다.</li></ul>이 외에도 다양한 정보가 저장될 수 있다.<br /><br />키체인은 데이터를 암호화하여 저장하기 때문에, 데이터를 분석하려면 암호화된 키체인 파일과 패스워드 또는 메모리 이미지에서 추출한 마스터 키가 필요하다. 메모리 이미지에서 마스터 키를 추출하는 방법은 예전에 설명한 적이 있으니, 해당 내용을 참조하기 바란다. [<a href="http://forensic.n0fate.com/2012/09/volafox-decrypting-keychain-file-using.html" target="_blank" title="">ref</a>]<br /><br />참고로 메모리 이미지는 사용자가 시스템을 조금만 건들더라도 데이터가 손상될 수 있으며, 행여나 시스템을 종료시키거나, 재부팅 시키는 경우에는 메모리 이미지에서 마스터 키를 추출할 수 없기 때문에, 라이브 데이터 수집과 더불어 가장 먼저 수집해야 한다. 메모리 이미지를 수집하는 방법은 다음과 같다.<br /><a href="http://%28null%29/" target="_self" title=""></a><br /><ul><li>MacResponsePro를 이용하기 : MacResponsePro는 Github에 등록된 Opensource Project로 라이브 데이터를 수집하는 포렌식 도구이다. 여러 수집 기능 중 메모리 이미징 기능을 제공하며, 결과 파일로 선형 포맷(Linear Format)의 이미지를 제공한다. EFI를 이용하여 수집하여 공식적인 API를 이용하기 때문에, 데이터 수집 기능이 안정적이다. 단, Lion 이후 버전에서는 지원하지 않는다. [<a href="http://macresponseforensics.com/" target="_blank" title="">ref</a>]</li><li>MacMemoryReader : volafox project 멤버인 Hajime Inoue가 개발한 이미징 도구로, 커널 코어 덤프(full dump)를 생성하는 방법으로 메모리 이미지를 수집한다. Leopard부터 Mountain Lion까지 전버전을 지원하며, 가장 빠르게 업데이트를 제공함으로 많은 포렌식 분석관이 사용하는 도구이다. 코어 덤프 파일이기 때문에 선형 포맷(Linear Format)이 아니지만, volafox의 flatten.py 를 이용하여 선형 포맷으로 변환할 수 있다. closed source project이다. [<a href="http://cybermarshal.com/index.php/cyber-marshal-utilities/mac-memory-reader" target="_blank" title="">ref</a>]</li><li>FW를 이용한 메모리 이미징 : Firewire 인터페이스는 DMA로 물리 메모리 장치에 직접 접근이 가능한 인터페이스이다. 이 인터페이스를 이용하면, 특정 명령을 전송하여 선형 포맷으로 메모리 이미지를 수집할 수 있다.  snow leopard까지는 가장 많이 사용되던 메모리 이미징 기법이지만, lion 10.7.1버전부터 FW의 버그로 인해 메모리 이미징 도중에 수집 시스템이 재부팅되는 버그가 발생된다. 그리고, 32비트 주소체계를 가지기 때문에 4기가 이상의 메모리를 이미징할 수 없다. 가장 대표적인 도구로 Inception이 있다. [<a href="http://www.blogger.com/blogger.g?blogID=7620918615785302711" target="_blank" title=""></a><a href="http://www.breaknenter.org/projects/inception/" target="_blank" title="">ref</a>]</li></ul>메모리를 이미징하는 방법은 위와 같이 3가지 방법이 있으나, MacMemoryReader를 가장 많이 사용하며, 추천하는 도구이다. 해당 도구를 사용하면 다음과 같은 순서로 메모리를 이미징할 수 있다.<br /><br /><pre> n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader<br />n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader <br />Password:<br />ATC-NY Mac Marshal Mac Memory Reader 3.0.2 ($Revision: 1.24 $)<br />Copyright (c) Architecture Technology Corporation.  All rights reserved.<br /><br />Usage: ./MacMemoryReader [-g] [-d] [-H hashtype] [-r] [-p] [-P] [-k] <filename><br /><br />   -g print progress messages suitable for parsing by a GUI<br />   -d print verbose debugging information to stderr<br />   -H compute the given hash on the output data (where hashtype<br />      is one of MD5, SHA-1, SHA-256, or SHA-512); can be given<br />      multiple times; hash is printed on stderr<br />   -r also copy "reserved" areas of memory, such as that used<br />      by shared-memory graphics adapters; EXPERIMENTAL<br />   -p dump memory in plain raw DD format instead of Mach-O, then write<br />      a table of contents to stderr listing file offsets versus<br />      physical memory offsets<br />   -P dump memory in plain raw DD format, inserting zeros for un-mapped<br />      regions in the memory map; no table of contents is needed,<br />      because file offsets will correspond to physical memory<br />      off
    sets, but the resulting file may be much larger than RAM<br />   -k
    load the RAM dump kernel extension and set up /dev/mem and<br />      /dev/pmap, but do not dump memory; for EXPERTS ONLY<br /><br />   dumps physical memory to <filename> in Mach-O (the default) or<br />   raw/DD format.  The resulting file may be slightly larger than<br />   physical memory due to the Mach-O header and alignment constraints.<br />   If the filename is '-', memory is dumped to stdout.<br /></filename></filename></pre>메모리 이미지를 수집하려면 간단하게 실행 파일 인자로 메모리 이미지를 저장할 파일 명을 준다. 보통 메모리 이미지를 생성하는 시점에 해시를 생성하므로 -H 옵션을 같이주는 것도 좋다.  <br /><pre>n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader test.mem<br />No kernel file specified, using '/mach_kernel' <br />Dumping memory regions:<br />available  0000000000000000 (572.00 KB)                               [WRITTEN]<br />ACPI_NVS   000000000008f000 (4.00 KB)                                 [WRITTEN]<br />available  0000000000090000 (64.00 KB)                                [WRITTEN]<br />available  0000000000100000 (178.00 MB)                               [WRITTEN]<br />LoaderData 000000000b300000 (76.00 KB)                                [WRITTEN]<br />available  000000000b313000 (948.00 KB)                               [WRITTEN]<br />LoaderData 000000000b400000 (5.21 MB)                                 [WRITTEN]<br />available  000000000b935000 (812.00 KB)                               [WRITTEN]<br />LoaderData 000000000ba00000 (33.00 MB)                                [WRITTEN]<br />RT_data    000000000daff000 (4.00 KB)                                 [WRITTEN]<br />RT_code    000000000db00000 (20.00 KB)                                [WRITTEN]<br />RT_data    000000000db05000 (4.00 KB)                                 [WRITTEN]<br />RT_code    000000000db06000 (4.00 KB)                                 [WRITTEN]<br />RT_data    000000000db07000 (4.00 KB)                                 [WRITTEN]<br />RT_data    000000000db08000 (4.00 KB)                                 [WRITTEN]<br />...[SNIP]...<br />available  00000000bfe93000 (4.00 KB)                                 [WRITTEN]<br />BS_data    00000000bfe94000 (40.00 KB)                                [WRITTEN]<br />available  00000000bfe9e000 (4.00 KB)                                 [WRITTEN]<br />available  00000000bfe9f000 (152.00 KB)                               [WRITTEN]<br />ACPI_NVS   00000000bfec5000 (8.00 KB)                                 [WRITTEN]<br />ACPI_recl  00000000bfec7000 (4.00 KB)                                 [WRITTEN]<br />ACPI_NVS   00000000bfec8000 (8.00 KB)                                 [WRITTEN]<br />ACPI_recl  00000000bfeca000 (12.00 KB)                                [WRITTEN]<br />ACPI_NVS   00000000bfecd000 (72.00 KB)                                [WRITTEN]<br />ACPI_recl  00000000bfedf000 (64.00 KB)                                [WRITTEN]<br />available  00000000bfeef000 (40.00 KB)                                [WRITTEN]<br />available  00000000bfeff000 (4.00 KB)                                 [WRITTEN]<br />available  0000000100000000 (5.00 GB) [.........                     ]  28.2% /^available  0000000100000000 (5.00 GB)                                 [WRITTEN]<br />Reported physical memory: 8589934592 bytes (8.00 GB)<br />Statistics for each physical memory segment type:<br />  reserved: 2 segments, 268460032 bytes (256.02 MB) -- assigned to unreadable device<br />  LoaderCode: 2 segments, 516096 bytes (504.00 KB) -- WRITTEN<br />  LoaderData: 4 segments, 44355584 bytes (42.30 MB) -- WRITTEN<br />  BS_code: 65 segments, 1388544 bytes (1.32 MB) -- WRITTEN<br />  BS_data: 80 segments, 38965248 bytes (37.16 MB) -- WRITTEN<br />  RT_code: 16 segments, 163840 bytes (160.00 KB) -- WRITTEN<br />  RT_data: 15 segments, 135168 bytes (132.00 KB) -- WRITTEN<br />  available: 43 segments, 8232214528 bytes (7.67 GB) -- WRITTEN<br />  ACPI_recl: 3 segments, 81920 bytes (80.00 KB) -- WRITTEN<br />  ACPI_NVS: 7 segments, 2211840 bytes (2.11 MB) -- WRITTEN<br />  MemMapIO: 7 segments, 4198400 bytes (4.00 MB) -- assigned to unreadable device<br />Total memory written: 8320032768 bytes (7.75 GB)<br />Total memory assigned to unreadable devices (not written): 272658432 bytes (260.03 MB)<br />n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ <br /></pre><br /><br />위와 같은 형태의 결과가 보이면, 메모리 이미지를 성공적으로 수행한 것이다. 다음 포스팅에서는 키체인 파일을 수집하는 방법을 알아보도록 하겠다.<div>n0fate's Forensic Space :)</div>
  fusion_builder_converted: 'yes'
author:
  login: n0fate
  email: rapfer@gmail.com
  display_name: n0fate
  first_name: ''
  last_name: ''
---
<p>디지털 포렌식 분석을 진행 과정에서 사용자의 기밀 정보는 매우 유용한 정보 중 하나이다. 보통 사용자는 자신에게 불리할 수 있는 증거를 숨기기 위해 데이터를 암호화하여 보관하거나, 인증을 통해서만 접근 가능한 환경에 보관하기 때문에 수사관 입장에서는 이러한 정보를 수집하기 쉽지 않다. 물론 갖은 회유와 협박을 통해 인증 정보를 수집할 순 있겠으나, 사용자가 이를 거부하는 경우에는 전수조사를 제외하곤 대책이 없다. (다른 방법이 있을 수 있으나, 적어도 내가 아는 상황에서는 그렇다.)</p>
<p>사용자는 자체적인 정보 암호화 알고리즘을 사용할 수도 있으나, 보통은 이미 안정성이 입증된 솔루션을 사용한다. 이러한 정보는 보통 다음과 같은 장소에 보관한다.
<ul>
<li>자체 암호화 솔루션 사용 : 암호화 프로그램을 통해 데이터를 암호화하거나, 파일 형태의 암호화 볼륨을 생성하여 데이터를 관리할 수 있게 한다. 대표적으로 TrueCrypt가 있다.</li>
<li>운영체제에서 지원하는 암호화 기능 사용 : 운영체제에서 제공하는 전체 디스크 암호화나 특정 파일 암호화 기술을 사용하여 데이터를 보관한다. 대표적으로 윈도우의 Bitlocker와 Mac OS X의 FileVault2, Keychain System이 있다.</li>
<li>클라우드 서비스 사용 : 외부 저장소 서비스를 이용하여 데이터를 저장하는 방법이다. Google Docs, Dropbox, Evernote 등이 있다.</li>
</ul>
<p>이런 다양한 정보 중에 오늘 글에서 다룰 내용은 키체인(Keychain) 분석이다. Mac OS X는 사용자 기밀 정보를 저장하기 위해 키체인(Keychain) 시스템을 운영하고 있다. 키체인 시스템은 사용자 정보를 3DES로 암호화하여 저장하고 있다. 키체인에는 Mac OS X에 저장되는 대부분의 기밀 정보를 저장한다. 대표적인 정보는 다음과 같다.
<ul>
<li>웹서비스 계정 정보 : Safari나 Chrome과 같은 웹 브라우저를 통해 저장되는 Dropbox, Evernote 등의 웹서비스 계정 정보</li>
<li>메신저 서비스 계정 정보 : Adium이나 iMessage에서 저장한 사용자 계정 정보</li>
<li>암호화된 볼륨 패스워드 : Mac OS X 사용자는 외부 저장 장치의 데이터를 암호화하여 보관하기 위해 해당 볼륨을 FileVault2로 암호화할 수 있다. 만약 암호화 볼륨을 마운트하는 과정에서 편의를 위해 사용자 패스워드를 저장하도록하면, 키체인에서 추출할 수 있다.</li>
<li>이메일, 연락처, 일정 계정 정보 : Mac OS X에서 기본적으로 제공하는 PIM(Personal Information Management) 시스템은 여러 클라우드 서비스와 연동이 가능하다. 연동한 계정의 ID와 패스워드가 키체인에 저장되어 있다.</li>
<li>기타 애플리케이션 암호화 정보 : 애플리케이션 개발자가 Mac OS X의 키체인 API를 사용하는 경우 암호화한 모든 데이터가 키체인 파일에 저장된다.</li>
<li>보안 노트 : 사용자가 정보를 은닉하기 위해 키체인 파일 내부에 RIch File Format의 문서를 생성할 수 있다. 대부분의 포렌식 수사관이 Mac OS X에 친숙하지 않아 분석에서 제외되는 경우가 많다보니, 이 곳에 정보를 은닉할 수 있다.</li>
</ul>
<p>이 외에도 다양한 정보가 저장될 수 있다.</p>
<p>키체인은 데이터를 암호화하여 저장하기 때문에, 데이터를 분석하려면 암호화된 키체인 파일과 패스워드 또는 메모리 이미지에서 추출한 마스터 키가 필요하다. 메모리 이미지에서 마스터 키를 추출하는 방법은 예전에 설명한 적이 있으니, 해당 내용을 참조하기 바란다. [fusion_builder_container hundred_percent="yes" overflow="visible"][fusion_builder_row][fusion_builder_column type="1_1" background_position="left top" background_color="" border_size="" border_color="" border_style="solid" spacing="yes" background_image="" background_repeat="no-repeat" padding="" margin_top="0px" margin_bottom="0px" class="" id="" animation_type="" animation_speed="0.3" animation_direction="left" hide_on_mobile="no" center_content="no" min_height="none"][<a href="http://forensic.n0fate.com/2012/09/volafox-decrypting-keychain-file-using.html" target="_blank" title="">ref</a>]</p>
<p>참고로 메모리 이미지는 사용자가 시스템을 조금만 건들더라도 데이터가 손상될 수 있으며, 행여나 시스템을 종료시키거나, 재부팅 시키는 경우에는 메모리 이미지에서 마스터 키를 추출할 수 없기 때문에, 라이브 데이터 수집과 더불어 가장 먼저 수집해야 한다. 메모리 이미지를 수집하는 방법은 다음과 같다.<br /><a href="http://%28null%29/" target="_self" title=""></a>
<ul>
<li>MacResponsePro를 이용하기 : MacResponsePro는 Github에 등록된 Opensource Project로 라이브 데이터를 수집하는 포렌식 도구이다. 여러 수집 기능 중 메모리 이미징 기능을 제공하며, 결과 파일로 선형 포맷(Linear Format)의 이미지를 제공한다. EFI를 이용하여 수집하여 공식적인 API를 이용하기 때문에, 데이터 수집 기능이 안정적이다. 단, Lion 이후 버전에서는 지원하지 않는다. [<a href="http://macresponseforensics.com/" target="_blank" title="">ref</a>]</li>
<li>MacMemoryReader : volafox project 멤버인 Hajime Inoue가 개발한 이미징 도구로, 커널 코어 덤프(full dump)를 생성하는 방법으로 메모리 이미지를 수집한다. Leopard부터 Mountain Lion까지 전버전을 지원하며, 가장 빠르게 업데이트를 제공함으로 많은 포렌식 분석관이 사용하는 도구이다. 코어 덤프 파일이기 때문에 선형 포맷(Linear Format)이 아니지만, volafox의 flatten.py 를 이용하여 선형 포맷으로 변환할 수 있다. closed source project이다. [<a href="http://cybermarshal.com/index.php/cyber-marshal-utilities/mac-memory-reader" target="_blank" title="">ref</a>]</li>
<li>FW를 이용한 메모리 이미징 : Firewire 인터페이스는 DMA로 물리 메모리 장치에 직접 접근이 가능한 인터페이스이다. 이 인터페이스를 이용하면, 특정 명령을 전송하여 선형 포맷으로 메모리 이미지를 수집할 수 있다.  snow leopard까지는 가장 많이 사용되던 메모리 이미징 기법이지만, lion 10.7.1버전부터 FW의 버그로 인해 메모리 이미징 도중에 수집 시스템이 재부팅되는 버그가 발생된다. 그리고, 32비트 주소체계를 가지기 때문에 4기가 이상의 메모리를 이미징할 수 없다. 가장 대표적인 도구로 Inception이 있다. [<a href="http://www.blogger.com/blogger.g?blogID=7620918615785302711" target="_blank" title=""></a><a href="http://www.breaknenter.org/projects/inception/" target="_blank" title="">ref</a>]</li>
</ul>
<p>메모리를 이미징하는 방법은 위와 같이 3가지 방법이 있으나, MacMemoryReader를 가장 많이 사용하며, 추천하는 도구이다. 해당 도구를 사용하면 다음과 같은 순서로 메모리를 이미징할 수 있다.</p>
<pre> n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader<br />n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader <br />Password:<br />ATC-NY Mac Marshal Mac Memory Reader 3.0.2 ($Revision: 1.24 $)<br />Copyright (c) Architecture Technology Corporation.  All rights reserved.<br /><br />Usage: ./MacMemoryReader [-g] [-d] [-H hashtype] [-r] [-p] [-P] [-k] <filename><br /><br />   -g print progress messages suitable for parsing by a GUI<br />   -d print verbose debugging information to stderr<br />   -H compute the given hash on the output data (where hashtype<br />      is one of MD5, SHA-1, SHA-256, or SHA-512); can be given<br />      multiple times; hash is printed on stderr<br />   -r also copy "reserved" areas of memory, such as that used<br />      by shared-memory graphics adapters; EXPERIMENTAL<br />   -p dump memory in plain raw DD format instead of Mach-O, then write<br />      a table of contents to stderr listing file offsets versus<br />      physical memory offsets<br />   -P dump memory in plain raw DD format, inserting zeros for un-mapped<br />      regions in the memory map; no table of contents is needed,<br />      because file offsets will correspond to physical memory<br />      off
sets, but the resulting file may be much larger than RAM<br />   -k
load the RAM dump kernel extension and set up /dev/mem and<br />      /dev/pmap, but do not dump memory; for EXPERTS ONLY<br /><br />   dumps physical memory to <filename> in Mach-O (the default) or<br />   raw/DD format.  The resulting file may be slightly larger than<br />   physical memory due to the Mach-O header and alignment constraints.<br />   If the filename is '-', memory is dumped to stdout.<br /></filename></filename></pre>
<p>메모리 이미지를 수집하려면 간단하게 실행 파일 인자로 메모리 이미지를 저장할 파일 명을 준다. 보통 메모리 이미지를 생성하는 시점에 해시를 생성하므로 -H 옵션을 같이주는 것도 좋다.  
<pre>n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ sudo ./MacMemoryReader test.mem<br />No kernel file specified, using '/mach_kernel' <br />Dumping memory regions:<br />available  0000000000000000 (572.00 KB)                               [WRITTEN]<br />ACPI_NVS   000000000008f000 (4.00 KB)                                 [WRITTEN]<br />available  0000000000090000 (64.00 KB)                                [WRITTEN]<br />available  0000000000100000 (178.00 MB)                               [WRITTEN]<br />LoaderData 000000000b300000 (76.00 KB)                                [WRITTEN]<br />available  000000000b313000 (948.00 KB)                               [WRITTEN]<br />LoaderData 000000000b400000 (5.21 MB)                                 [WRITTEN]<br />available  000000000b935000 (812.00 KB)                               [WRITTEN]<br />LoaderData 000000000ba00000 (33.00 MB)                                [WRITTEN]<br />RT_data    000000000daff000 (4.00 KB)                                 [WRITTEN]<br />RT_code    000000000db00000 (20.00 KB)                                [WRITTEN]<br />RT_data    000000000db05000 (4.00 KB)                                 [WRITTEN]<br />RT_code    000000000db06000 (4.00 KB)                                 [WRITTEN]<br />RT_data    000000000db07000 (4.00 KB)                                 [WRITTEN]<br />RT_data    000000000db08000 (4.00 KB)                                 [WRITTEN]<br />...[SNIP]...<br />available  00000000bfe93000 (4.00 KB)                                 [WRITTEN]<br />BS_data    00000000bfe94000 (40.00 KB)                                [WRITTEN]<br />available  00000000bfe9e000 (4.00 KB)                                 [WRITTEN]<br />available  00000000bfe9f000 (152.00 KB)                               [WRITTEN]<br />ACPI_NVS   00000000bfec5000 (8.00 KB)                                 [WRITTEN]<br />ACPI_recl  00000000bfec7000 (4.00 KB)                                 [WRITTEN]<br />ACPI_NVS   00000000bfec8000 (8.00 KB)                                 [WRITTEN]<br />ACPI_recl  00000000bfeca000 (12.00 KB)                                [WRITTEN]<br />ACPI_NVS   00000000bfecd000 (72.00 KB)                                [WRITTEN]<br />ACPI_recl  00000000bfedf000 (64.00 KB)                                [WRITTEN]<br />available  00000000bfeef000 (40.00 KB)                                [WRITTEN]<br />available  00000000bfeff000 (4.00 KB)                                 [WRITTEN]<br />available  0000000100000000 (5.00 GB) [.........                     ]  28.2% /^available  0000000100000000 (5.00 GB)                                 [WRITTEN]<br />Reported physical memory: 8589934592 bytes (8.00 GB)<br />Statistics for each physical memory segment type:<br />  reserved: 2 segments, 268460032 bytes (256.02 MB) -- assigned to unreadable device<br />  LoaderCode: 2 segments, 516096 bytes (504.00 KB) -- WRITTEN<br />  LoaderData: 4 segments, 44355584 bytes (42.30 MB) -- WRITTEN<br />  BS_code: 65 segments, 1388544 bytes (1.32 MB) -- WRITTEN<br />  BS_data: 80 segments, 38965248 bytes (37.16 MB) -- WRITTEN<br />  RT_code: 16 segments, 163840 bytes (160.00 KB) -- WRITTEN<br />  RT_data: 15 segments, 135168 bytes (132.00 KB) -- WRITTEN<br />  available: 43 segments, 8232214528 bytes (7.67 GB) -- WRITTEN<br />  ACPI_recl: 3 segments, 81920 bytes (80.00 KB) -- WRITTEN<br />  ACPI_NVS: 7 segments, 2211840 bytes (2.11 MB) -- WRITTEN<br />  MemMapIO: 7 segments, 4198400 bytes (4.00 MB) -- assigned to unreadable device<br />Total memory written: 8320032768 bytes (7.75 GB)<br />Total memory assigned to unreadable devices (not written): 272658432 bytes (260.03 MB)<br />n0fate@n0fate-ui-MacBook-Pro: ~/Downloads/MacMemoryReader$ <br /></pre>
<p>위와 같은 형태의 결과가 보이면, 메모리 이미지를 성공적으로 수행한 것이다. 다음 포스팅에서는 키체인 파일을 수집하는 방법을 알아보도록 하겠다.
<div>n0fate's Forensic Space :)</div>
<p>[/fusion_builder_column][/fusion_builder_row][/fusion_builder_container]</p>
